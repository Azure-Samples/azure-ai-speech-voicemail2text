# Configuration basics

Administrators and integrators can configure V2TIC deployments following this process: 
- Gather the specifications for your API.
- Create a profile script and templates.
- Create configuration and deployment files.
- [Build and deploy V2TIC](../build-deploy/build-summary.md).

## Gather specifications

Before creating profiles and configurations, you need to know what the transcription request and response look like:
- What are the headers and fields of the request? Which ones are mandatory? Which ones are custom headers? Languages?</li>
- Does the response have a standard response? What is the maximum length of the transcription? Are any mandatory custom headers required to be included in the response?

For example, this could be what an incoming request from a voicemail server looks like:

```
To: &lt;carrier&gt;-cc-voicemail@iot.slough.nuancevm.com 
    From: voice2textreply@example.com 
    Subject: New Voice Message
    Date: Fri, 31 Jan 2014 11:47:30 GMT
    Message-Id: 12345-abcde-67890
    X-Caller: 15551234567
    X-Caller-Name: John Smith
    X-Called: 15557654321
    X-Called-Name: Joe Bloggs
    X-Language: en-US
    Content-Type: audio/wav
    Content-Transfer-Encoding: base64

    UklGRqxhAABXQVZFZm10IBAAAAAHAAEAQB8AAEAfAAABAAgAZGF0YYBhAAD9
    &lt;snip&gt;
    yIS9kQ8qsgg9gAhkmAwN0ApI4YvqmBDd1Yvr+IzwGIdyOId0Wid2eId4mId6
```

You decide that the `From`, `To`, and `Message-Id` headers are mandatory.

For the response, you decide the `Message-Id` header is mandatory to include, and the maximum transcription length is 3000 characters (approximately 600 words).

## Create a profile and templates

The next step is to build the profile and templates based on the requirements you've gathered.

The templates are Jinja templates. To learn more about working with Jinja templates, go to [the Jinja documentation](https://jinja.palletsprojects.com/en/3.1.x/templates/). In V2TIC, these templates use the `.j2` extension. You must have at least `request.j2` and `response.j2` templates, which handle converting requests and responses, but you could have more depending on your needs.

Each deployment's profile and templates exist in a folder inside `etc/profiles`, with the templates in their own folder, like the samples included with the V2TIC project.

### Request template

The request template defines what to keep from the original incoming request, along with additional metadata and configurations.

Here is an example `request.j2` template for an SMTP deployment:

```
    {
        "profile": "sample-smtp",
        "scrid": "{{request.scrid}}",
        "pass_through_data": {
          "from": "{{request.headers.From}}",
          "to": "{{request.headers.To}}",
          "message_id": "{{request.headers['Message-Id']}}"
            },
        "metadata": {
          "deposit_time": "{{request.deposit_time}}",
          "language": "{{request.headers['X-Language']}}",
          "language_configuration": {
            "en-US": {
                    "min_confidence_percentage": "60",
                    "max_audio_length_msecs": "240000"
                },
                "es-US": {
                    "min_confidence_percentage": "55",
                    "max_audio_length_msecs": "240000"
                }
                    },
                    "max_conversion_length": "{{request.max_conversion_length}}"
            },
            "acs_client": {
                    "lid_enabled": "True",
        "lid_mode": "AtStartHighAccuracy",
        "profanity_option": "Masked",
        "log_transcriptions_enabled": "False"
      }
    }
```

These are the key parts of the template:
- `profile`: Required. Refers to the profile used by this deployment.
- `scrid`: The unique ID for this transcription, generated by V2TIC.
- `pass_through_data`: Contains key-pairs to be passed through into the response (in this example, the `From`, `To`, and `Message-Id` headers in the original request).
- `metadata`: Contains key-pairs for metadata of the profile.
- `acs_client`: Contains key-pair values for Azure AI configuration.

### Response template

The response template defines what content and in what order that content appears in the final response V2TIC sends out.

Here is an example `response.j2` template for an HTTPS deployment:

```
    {
        "return_url": "{{request.headers['X-Return-Url']}}",
        "verify_ssl": "false",
        "headers": {
          "Content-Type": "application/xml; charset=utf-8",
           "X-Reference": "{{request.scrid}}",
           {% if request.status == "Success" -%}
              "X-RTF": "{{request.recognition_result.rtf}}",
              {% if(request.recognition_result.conversion_status == "Transcribed" and request.recognition_result.lid_enabled) -%}
              "X-Detected-Language-Constellation": "{{request.recognition_result.detected_languages}}",
              {%- endif %}
           {%- endif %}
          "Connection": "close"
        },
        "body": {
           "import": "response_body.j2",
           "encoding": "utf-8"
        }
     } 
```

These are the key parts of the template:
- `return_url`: The URL where the final response is sent to. From the passthrough data.
- `headers`: Contains key-pair headers for the response.
- `body`: Defines the actual message in the response.
- `encoding`: Defines the encoding format. For example, utf-8, iso-8859-1, ascii, and more.

Here is an example `response.j2` template for an SMTP deployment:

```
    {
        {# optionally put response_address or will default to configured smtp.response_host:smtp.reponse_port
        "response_address": "192.168.1.4:9025",
        #}
     
        {# if start_tls is not configured, will default to false #}
        "start_tls": "false",
     
        {# fetch required metadata from pass_through_data or from original request headers #}
        "mail_from": "{{request.headers.To}}",
        "rcpt_to": "{{request.headers.From}}",
     
        "headers": {
          "Content-Type": "text/plain; charset=utf-8",
          "Subject": "{{request.headers.Subject}}",
          "Message-Id": "{{request.headers['Message-Id']}}",
          "Connection": "close"
        },
        "body": {
           "import": "response_body.j2",
           "encoding": "utf-8"
        }
     }
```

These are the key parts of the template:
- `mail_from`: An SMTP command.
- `rcpt_to`: An SMTP command.
- `headers`: Contains key-pair headers for the response.
- `body`: Defines the actual message in the response.
- `encoding`: Defines the encoding format. For example, utf-8, iso-8859-1, ascii, and more.

These examples use an additional template, `response-body.j2`, which defines the format of what the ultimate end user of the transcription will see.

Here is an example `response-body.j2` template for an SMTP deployment:

```
{{request.recognition_result.text}}

------------------------------------------
Transcribed using V2TIC

scrid: {{request.scrid}}
conversion_status: {{request.recognition_result.conversion_status}}
recognition_status: {{request.recognition_result.status}}
{% if request.recognition_result.conversion_status == "TRANSCRIBED" -%}
converted_text: {{request.recognition_result.text}}
{% else -%}
{{“This person called and left you a message. Please call voicemail – Nuance” }}
{%- endif %}
display_text: {{request.recognition_result.display_text}}
itn_text: {{request.recognition_result.itn_text}}
global_confidence_score: {{request.recognition_result.global_confidence_score}}
rtf: {{request.recognition_result.rtf}}
recognition_duration: {{request.recognition_result.duration}}
audio_duration_secs: {{request.recognition_result.final_audio_length_secs}}
audio_duration_mSecs: {{request.recognition_result.final_audio_length_msecs}}
audio_truncated: {{request.recognition_result.audio_truncated}}
requested_languages: {{request.recognition_result.requested_languages}}
{% if request.recognition_result.lid_enabled == "true" -%}
lid_enabled: true
detected_languages: {{request.recognition_result.detected_languages}}
{%- endif %}
```

> [!NOTE]
> This example mentions `itn_text`, which is Inverse Text Normalization. Go to the [Azure AI](https://learn.microsoft.com/en-us/azure/ai-services/speech-service/display-text-format?pivots=programming-language-python) documentation to learn more.

### Profile

`profile.py` defines a class for handling SMTP- or HTTPS-related operations. These include obtaining mandatory headers and how to handle responses based on the success or failure of transcription.

The profile imports fields, headers, and constants from `v2ticlib`. It also imports the global profile class from `AbstractProfile` in the `Common` folder.

Here is an example `profile.py` template for an SMTP deployment:

```
    import typing
import v2ticlib.constants.fields as Fields
import v2ticlib.constants.headers as Headers
import v2ticlib.constants.constants as constants
from Common.abstract_profile import AbstractProfile

class SampleSmtpProfile(AbstractProfile):

    def get_mandatory_headers(cls):
        return [Headers.FROM, Headers.MESSAGE_ID, Headers.TO]

    def get_request_context(cls, context:dict[str, any], headers:typing.Mapping[str, str]) -> dict[str, any]:
        context[Fields.MAX_CONVERSION_LENGTH] = 3000
        return context

    def update_response_hook(cls, request: dict[str, any], response: dict[str, any]) -> dict[str, any]:
        recognition_result = request[Fields.RECOGNITION_RESULT]
        if recognition_result[Fields.STATUS] == constants.TRANSCRIPTION_SUCCESS and recognition_result[Fields.LID_ENABLED] == constants.TRUE:
            response[Fields.HEADERS][Headers.X_DETECTED_LANGUAGE_CONSTELLATION] = recognition_result[Fields.DETECTED_LANGUAGES]

        return response
```

This profile also declares the maximum character length for the transcription from the Gather Requirements step: <code>context[Fields.MAX_CONVERSION_LENGTH] = 3000</code>. This profile class also has a unique name.

## Create configuration and deployment files

After creating the profile and templates, you can create the `configmap-file.yaml` and `deployment.yaml` files. These files define and configure the V2TIC image you'll build for your deployment.

These files have fixed formats and must be in a folder under `etc/deployments`. When creating your own, use the samples provided in the project. Only change the values of the key-pairs. Go to [Configuration fields](../reference/deploy-configurations-templates.md) to learn about creating `configmap-file.yaml` files.

## What's next

Once you've created your profile, template, configuration, and deployment files, you can [build and deploy](../build-deploy/build-summary.md) your V2TIC deployment.

[Return to table of contents](../index.md)